# -*- coding: utf-8 -*-
"""
Created on Mon Apr 26 13:01:48 2021

@author: Jan Baijens, janbaijens@live.nl

This script creates histograms for PAM counts based on edits files generated using clinvar_mutations_to_PE_fasta.py
And boxplots, violinplots for predicted editing effiencies, using output from PE_Position and PE_Type, and clinvar_mutations file,
generated by create_human_pathogenic_mutation_table.py.
"""

#Import libraries:
import os
from pathlib import Path
import numpy as np
import pandas as pd
import collections
import matplotlib.pyplot as plt
import seaborn as sns
#from scipy import stats
from Bio import SeqIO, Seq
import matplotlib.pyplot as plt
from time import gmtime, strftime
date = strftime('%m-%d', gmtime())
plt.style.use('ggplot')

#Setup working environment and paths:
current_dir = os.getcwd() #Make sure to run from Scripts directory.
PE_efficiency_dir = Path(os.path.split(current_dir)[0]) #Move up one directory
Figures_dir = PE_efficiency_dir / 'Figures'
Files_dir = PE_efficiency_dir / 'Files'
Data_dir = PE_efficiency_dir / 'Data'

#Load data:
clinvar_mutations = pd.read_csv(str(Data_dir / '01-03Clinvar_mutations.csv'), low_memory = False)
clinvar_mutations_set = set(clinvar_mutations['Canonical SPDI'])
edits = pd.read_csv(str(Data_dir / '03-14edits_NGG.csv'), low_memory = False)

#mutation_info = []
#for PAM in ('NGG', 'NAN', 'NGN'):
#    print('PAM: {}'.format(PAM))
#    PAM_edits = pd.read_csv(str(Data_dir / '05-05edits_{}.csv'.format(PAM)), low_memory = False)
#    PAM_mutations = set(PAM_edits['Canonical SPDI'])
#    PAM_by_mutation = PAM_edits.groupby('Canonical SPDI')
#    for mutation in clinvar_mutations_set:
#        row = {'SPDI' : mutation, 'PAM' : PAM}
#        if mutation in PAM_mutations:
#            group = PAM_by_mutation.get_group(mutation)
#            strand_pam_locations = group['strand'] + group['pam_location'].astype(str)
#            nr_PAMS = len(set(strand_pam_locations))
#            row['count'] = nr_PAMS
#        else:
#            row['count'] = 0
#        mutation_info.append(row)
#mutation_df = pd.DataFrame(mutation_info)
#
##Save mutation_df
#mutation_df.to_csv(str(Data_dir / '{}PAM_counts.csv'.format(date)), index = False)
mutation_df = pd.read_csv(str(Data_dir / '{}PAM_counts.csv'.format(date)))

#Histogram of nr PAMs per mutation
pal = ['#118002', '#074080', '#800002', '#E37509']
c_bins = np.arange(0, 19, 1)
mid_c_bins = c_bins + 0.5
comb = np.array(mutation_df.loc[mutation_df['PAM'] == 'NGN']['count']) + np.array(mutation_df.loc[mutation_df['PAM'] == 'NAN']['count'])
plt.hist(comb, c_bins, color = pal[3], cumulative = -1, density = 1, label = 'NGN + NAN')
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NGG']['count'], c_bins, label = 'NGG', color = pal[0], cumulative = -1, density = 1)
#plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NGN']['count'], c_bins, alpha = 0.5, label = 'NGN', color = 'green')
plt.xticks(mid_c_bins, c_bins)
plt.title('Number of NGN + NAN PAMs nearby clinvar mutations')
plt.xlabel('Number of nearby PAMs')
plt.ylabel('requency')
plt.legend(loc = 'upper right')
plt.savefig(str(Figures_dir / '{}_PAM_count_hist_NGN_NAN.png'.format(date)), dpi = 600)
plt.show()

#Cumulative hist
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NGG']['count'], c_bins, alpha = 0.5, label = 'NGG', color = 'red', cumulative = -1)
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NAN']['count'], c_bins, alpha = 0.5, label = 'NAN', color = 'blue', cumulative = -1)
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NGN']['count'], c_bins, alpha = 0.5, label = 'NGN', color = 'green', cumulative = -1)
plt.xticks(mid_c_bins, c_bins)
plt.title('Cumulative number of PAMs nearby clinvar mutations')
plt.xlabel('Number of nearby PAMs')
plt.ylabel('Frequency')
plt.legend(loc = 'upper right')
plt.savefig(str(Figures_dir / '{}_PAM_count_hist_cumulative.png'.format(date)), dpi = 600)
plt.show()

#Cumulative density hist
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NGG']['count'], c_bins, alpha = 0.5, label = 'NGG', color = 'red', cumulative = -1, density = 1)
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NAN']['count'], c_bins, alpha = 0.5, label = 'NAN', color = 'blue', cumulative = -1, density = 1)
plt.hist(mutation_df.loc[mutation_df['PAM'] == 'NGN']['count'], c_bins, alpha = 0.5, label = 'NGN', color = 'green', cumulative = -1, density = 1)
plt.xticks(mid_c_bins, c_bins)
plt.title('Cumulative number of PAMs nearby clinvar mutations')
plt.xlabel('Number of nearby PAMs')
plt.ylabel('Relative frequency')
plt.legend(loc = 'upper right')
plt.savefig(str(Figures_dir / '{}_PAM_count_hist_cumulative_density.png'.format(date)), dpi = 600)
plt.show()

#Stacked histogram of nr PAMs per mutation
c_bins = np.arange(0, 19, 1)
mid_c_bins = c_bins + 0.5
counts = [mutation_df.loc[mutation_df['PAM'] == 'NGG']['count'], mutation_df.loc[mutation_df['PAM'] == 'NAN']['count'], mutation_df.loc[mutation_df['PAM'] == 'NGN']['count']]
labels = ['NGG', 'NAN', 'NGN']
plt.hist(counts, c_bins, label = labels, stacked = True)
plt.legend(labels = labels, loc = 'upper right')
#plt.hist(counts, c_bins)
plt.xticks(mid_c_bins, c_bins)
plt.title('Number of PAMs nearby clinvar mutations')
plt.xlabel('Number of nearby PAMs')
plt.ylabel('Frequency')
plt.legend(loc = 'upper right')
plt.savefig(str(Figures_dir / '{}_PAM_count_hist_stacked.png'.format(date)), dpi = 600)
plt.show()

#Stacked cumulative hist
plt.hist(counts, c_bins, label = labels, stacked = True, cumulative = -1)
plt.legend(labels = labels)
plt.xticks(mid_c_bins, c_bins)
plt.title('Cumulative number of PAMs nearby clinvar mutations')
plt.xlabel('Number of nearby PAMs')
plt.ylabel('Frequency')
plt.legend(loc = 'upper right')
plt.savefig(str(Figures_dir / '{}_PAM_count_hist_stacked_cumulative.png'.format(date)), dpi = 600)
plt.show()

#Stacked cumulative density hist
plt.hist(counts, c_bins, label = labels, stacked = True, cumulative = -1, density = 1)
plt.legend(labels = labels)
plt.xticks(mid_c_bins, c_bins)
plt.title('Cumulative number of PAMs nearby clinvar mutations')
plt.xlabel('Number of nearby PAMs')
plt.ylabel('Relative frequency')
plt.legend(loc = 'upper right')
plt.savefig(str(Figures_dir / '{}_PAM_count_hist_stacked_cumulative_density.png'.format(date)), dpi = 600)
plt.show()

#Load predictions file, filter for forward orientation, get set of sequences, group by sequence
predictions = pd.read_csv(Data_dir / '05-03PE_prediction_output.csv')
predictions_f = predictions.loc[predictions.Location == '01:47'].copy()

pred_seq_set = set(predictions_f['Wide Target Sequence (47bp)'])
pred_by_seq = predictions_f.groupby('Wide Target Sequence (47bp)')

#Loop over edits, if edit was predicted, store max prediction to list (Max prediction because sometimes Type and Position both make prediction):
predictions = []
nonpredicted_seqs = []
for i in range(len(edits)):
    row = edits.iloc[i]
    prediction = np.nan
    if i%33333 == 0:
            print('Working on row: {}'.format(i))
    if row.predictable == 1:
        id_ = row.input_name
        seq = row.input_seq
        desired_edit = row.desired_edit
        if seq in pred_seq_set:
            preds = pred_by_seq.get_group(seq)
            pred_edits = set(preds.Edit)
            if desired_edit in pred_edits:
                prediction = max(preds.loc[preds.Edit == desired_edit]['Prediction Score'])
#                    row.predicted_efficiency = prediction
            else:
#                print('Houston we have a problem! Desired edit not found for {}'.format(i))
                nonpredicted_seqs.append(seq)
        
    predictions.append(prediction)

#Add maximum prediction column to dataframe:
edits['predicted_efficiency'] = predictions

#Save edits with predictions to file:
edits_with_pred = edits.loc[~edits['predicted_efficiency'].isnull()].copy()
edits_with_pred.to_csv(str(Data_dir / '{}edits_NGG_with_predictions.csv'.format(date)), index = False)
nr_predictions_made = len(edits_with_pred)

#Group edits by SPDI, to get numbers per mutation instead of per edit:
edits_by_SPDI = edits.groupby('Canonical SPDI')
edits_SPDIs = set(edits['Canonical SPDI'])
#Loop over mutations, add max_predicted efficiency, nr predicted cols:
nr_preds = []
max_preds = []
for i in range(len(clinvar_mutations)):
    if i%33333 == 0:
        print('Working on row: {}'.format(i))
    row = clinvar_mutations.iloc[i]
    nr = 0
    max_p = np.nan
    if row['Canonical SPDI'] in edits_SPDIs:
        group = edits_by_SPDI.get_group(row['Canonical SPDI'])
        group_preds = group.loc[~group.predicted_efficiency.isnull()]
        nr = len(group_preds)
        if nr > 0:
            max_p = max(group_preds.predicted_efficiency)
    nr_preds.append(nr)
    max_preds.append(max_p)
clinvar_mutations['nr_preds'] = nr_preds
clinvar_mutations['max_pred'] = max_preds

#Save to file:
clinvar_mutations.to_csv(str(Data_dir / '{}clinvar_mutations_w_predictions.csv'.format(date)), index = False)

#Make boxplots
clinvar_mutations_predicted = clinvar_mutations.loc[~clinvar_mutations.max_pred.isnull()]
clinvar_mutations_predicted_5 = clinvar_mutations_predicted.loc[clinvar_mutations_predicted.nr_preds <6].copy()

ax = sns.boxplot(data = clinvar_mutations_predicted, x = 'edit_type', y = 'max_pred')
plt.ylim(-5, 25)
n = ['n= ' + str(x) for x in clinvar_mutations_predicted['edit_type'].value_counts().values.tolist()]
pos = range(len(n))
for tick, label in zip(pos, ax.get_xticklabels()):
    ax.text(pos[tick], 23.5, n[tick], horizontalalignment = 'center')
#sns.swarmplot(data = clinvar_mutations_predicted, x = 'edit_type', y = 'max_pred', color = '.3', alpha = 0.3)
plt.title('Predicted efficiency per edit type')
plt.xlabel('')
plt.ylabel('Maximum predicted efficiency')
plt.savefig(str(Figures_dir / '{}_boxplot_max_eff_edit_type.png'.format(date)), dpi = 600)
plt.show()

ax = sns.boxplot(data = clinvar_mutations_predicted_5, x = 'nr_preds', y = 'max_pred', palette = pal)
plt.ylim(-5, 25)
n = ['n = ' + str(x) for x in clinvar_mutations_predicted_5['nr_preds'].value_counts().values.tolist()]
pos = range(len(n))
for tick, label in zip(pos, ax.get_xticklabels()):
    ax.text(pos[tick], 23.5, n[tick], horizontalalignment = 'center', fontsize = 10)
#sns.swarmplot(data = clinvar_mutations_predicted, x = 'nr_preds', y = 'max_pred', color = '.3', alpha = 0.3)
plt.title('Maximum predicted efficiency per number of PAMs')
plt.xlabel('Number of PAMs')
plt.ylabel('Maximum predicted efficiency')
plt.savefig(str(Figures_dir / '{}_boxplot_max_eff_nr_pred.png'.format(date)), dpi = 600)
plt.show()

plt.style.use('seaborn-white')
pal = sns.color_palette('husl', 5)

ax = sns.violinplot(data = clinvar_mutations_predicted_5, x = 'nr_preds', y = 'max_pred', scale = 'width', palette = pal)
plt.ylim(-6, 26)
n = ['n=' + str(x) for x in clinvar_mutations_predicted_5['nr_preds'].value_counts().values.tolist()]
pos = range(len(n))
for tick, label in zip(pos, ax.get_xticklabels()):
    ax.text(pos[tick], 24, n[tick], horizontalalignment = 'center', fontsize = 10)
plt.title('Maximum predicted efficiency per number of PAMs')
plt.xlabel('Number of PAMs')
plt.ylabel('Maximum predicted efficiency')
plt.savefig(str(Figures_dir / '{}_violinplot_max_eff_nr_pred5.png'.format(date)), dpi = 600)
plt.show()

pal = sns.color_palette('husl', 6)
clinvar_mutations_predicted_6 = clinvar_mutations_predicted.loc[clinvar_mutations_predicted.nr_preds <7].copy()
ax = sns.violinplot(data = clinvar_mutations_predicted_6, x = 'nr_preds', y = 'max_pred', scale = 'width', palette = pal)
plt.ylim(-6, 26)
n = ['n=' + str(x) for x in clinvar_mutations_predicted_6['nr_preds'].value_counts().values.tolist()]
pos = range(len(n))
for tick, label in zip(pos, ax.get_xticklabels()):
    ax.text(pos[tick], 24, n[tick], horizontalalignment = 'center', fontsize = 10)
plt.title('Maximum predicted efficiency per number of PAMs')
plt.xlabel('Number of PAMs')
plt.ylabel('Maximum predicted efficiency')
plt.savefig(str(Figures_dir / '{}_violinplot_max_eff_nr_pred6.png'.format(date)), dpi = 600)
plt.show()
#Barplot:
sns.barplot(data = clinvar_mutations_predicted, x = 'nr_preds', y = 'max_pred')
